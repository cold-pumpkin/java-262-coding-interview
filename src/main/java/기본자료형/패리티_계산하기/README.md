# 문제 4.1 패리티 계산하기
### Q. 64비트로 이루어진 숫자의 패리티 계산하기
**※ 2진수의 패리티**
* 보통 데이터를 저장하거나 네트워크 통신을 할 때 정보 전달 과정에서 오류를 확인하는 용도로 사용하는 값
* 1로 세팅된 비트의 총 개수를 2로 나는 나머지 값과 같음
* 1이 홀수 개이면 1, 짝수 개이면 0
  * ex) 1011의 패리티 = 1
  * ex) 1000100의 패리티 = 0

### A1. 1로 세팅된 모든 비트의 개수 세기
* 주어진 입력값을 처음부터 끝까지 탐색하며 비트1의 개수가 홀수인 경우 1, 짝수인 경우 0을 리턴
* 비트가 1인 개수를 더해 홀짝을 판단하기 보다, **비트 연산자**를 활용
  * [풀이 코드](Solution.java)
* 입력 크기가 n인 경우 시간 복잡도 `O(n)`

**※ TIP**
* `>>>`
  주어진 수 만큼 오른쪽으로 비트를 이동시키는 연산자
  * 이동하며 생긴 빈자리는 0으로 채움
    * cf) `>>` 연산자는 부호비트로 채움
* `^`
  * `XOR` 연산자
  * `A ^ B` 일 때, A와 B가 같으면 0, 다르면 1 리턴

### A2. 비트 조작 트릭
* `x & (x - 1)` 연산은 x의 가장 마지막 1을 0으로 바꿔줌
  * ex) 1회차 : 00101100 & 00101011 = 00101000
  * ex) 2회차 : 00101000 & 00100111 = 00100000
  * ex) 3회차 : 00100000 & 00011111 = 00000000
    * 3회 반복 = 1이 3개(홀수) = 패리티 1
  * 1이 모두 0이 될 때 까지 위 연산을 반복, 연산이 반복된 횟수의 홀/짝을 판단하여 리턴
    * [풀이 코드](Solution2.java)
  * 1로 셋팅된 비트의 개수가 k일 경우, 시간 복잡도 `O(k)`

